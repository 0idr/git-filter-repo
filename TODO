Crazy ideas, showing filter-repo flexibility:
  - show modifying mode (e.g. mark executable)
  - delete commits older than certain date (simple commit.skip())
  - alternative path filtering
    - doing case-insensitive path deletion
    - clean via (current) .gitignore files [see git-check-ignore]
  - removing/inserting files
    - removing symlinks?
    - adding a new file (LICENSE/COPYING) to the beginning of history
    - remove a submodule (copy contents into tree for each submodule commit)
    - extract to submodule (where to put submodule history though?)
    - convert to git lfs
  - reformatting (lint) files in history [maybe only via git-very-bad-idea??]
  - extend argument parser and use extended version
  - git-bfgish (bfg) and git-very-bad-idea (filter-branch, on changed-only tree)

More thorough testing
  - commit pruning
    - coalescing common commits of a merge
      - what about when splicing repos; does it still work?
  - ref pruning
    - tags pointing at commits which are pruned along with their history
      - refs pointing at commits which are pruned along with their history
      - refs or tags behind a negative revision specification
  - splitting a repo in addition to splicing
  - commit message rewriting
    - does it also work with repo splicing/splitting?
  - renaming, particular when it causes collisions
  - use coverage.py to direct test writing

Repository diffing
  - New ideas:
    - Basically, diffing `git log --raw --all --format="commit %s"` output
    - Add flags to allow customization; examples
      - --pretty=fuller instead of --format
      - -p or --name-status instead of --raw
  - Old ideas:
    - Specialized fast-export --no-data --show-original-ids --all output
    - If blobs differ, then I manually augment output with blob info
    - Replace "from :<id>" with "from :<commit-msg-summary>"
    - Filter out original ids, but remember them
    - Change "commit <refname>" lines into just "commit"
    - At the end, augment with "reset <refname> from :<commit-msg-summary>"
      for each non-tag refname, in sorted order

Bug reporting:
  git.git:
    - fast export fails on tags of blobs (example: git.git)
    - fast export fails on tags of tags (example: git.git)
      - $ git fast-export --no-data --use-done-feature --signed-tags=strip \
              --tag-of-filtered-object=rewrite-feature v1.0rc1 >/dev/null
      fatal: tag 5f4cd4ca015dc795b9f7f4fed11b3f80a60ac175 tags unexported tag!
    - [fundamental] fast export fails on tags of trees (example: linux.git)
    - fast export does not report annotated/signed tags outside of refs/tags/
      namespace correctly when name doesn't match internal 'tag' field.
    - fast import always places tags under refs/tags/, which combined with
      fast export reported tags outside of refs/tags/ weird means we get tags
      that migrate to new locations.

Handle tags of trees:
  - create commit has the given tree as main objects, rewrite the tag to tag it
  - run it through normal filter-repo stuff
  - at the end, rewrite the tag to tag its commit's tree

Document or start conversation around interaction with external systems:
  - May not be able to force push over e.g. refs/changes/, refs/pulls/, etc.
  - People need a way to do "update project", and get GitHub/Gerrit/Gitlab fixed

Other feature ideas:
  - Compatibility:
    - Handle grafts and replace files
    - Is any work needed to handle submodules?
  - Options:
    - paths-from-file (similar to --replace-text, maybe also invert or basename?)
    - include-old-names-of-specified-files (auto get rename data from --analyze?)
    - Write git notes mapping old ids to new ids (or make special references?)
    - add --skip-cleanup (pruning, gc, etc.; keep reset --hard) for speed compare
    - Old list:
      - --keep-excluded-revisions
      - --keep-excluded-refs
      - --store-backup
      - --empty-pruning={no/off,auto,always/on}
      - --no-ff-pruning={no/off,auto,always/on}
      - --negative-refs={drop,reference}

Cleanups and left-over bits:
  - put $(git --exec-path) in front of PYTHONPATH before importing?
  - should handle remote symrefs better (don't special case origin/HEAD)
  - metadata
    - On second and subsequent runs, update metadata instead of overwriting
       - for maps, give beginning_hash -> end_hash, not intermediate hashes
  - error out if any progress messages in stream (can't deal with them unless
    we can pass --cat-blob-fd to fast-import, and that seems non-portable)

Documentation
  - Examples, include these in:
    - help output
    - README.md
    - manpage
  - Backward compatiblity guarantees (or lack thereof)
    - Big comment at top of git-filter-tree
    - Reference caveat next to every import statement
  - Make list of caveats:
    - notes about history becoming incompatible (from rebase documentation)
    - signed tags will be stripped
    - empty commit pruning and topological changes
    - commit message rewriting
    - path rename collisions
    - all the git.git bug reports

Performance:
  - Smarter record_remapping -- do it lazily
  - Pathquoting memoization; or full result? (dequote -> do mods -> requote)
  - Smarter become-empty checks; only do more expensive checks if:
    - First parent is no longer original first parent or ancestor thereof
      - e.g. first-parent history empty, second parent becomes first parent
      - e.g. --parent-filter causes some kind of graft operation (although
             maybe we don't want to prune in this case anyway...)
    - Blob filtering is active AND the only file_changes involved correspond
      to filenames that have previously been modified.

Argument parsing stuff:
  # NOT YET IMPLEMENTED OPTIONS BELOW
  misc.add_argument('--empty-pruning', choices=['always', 'auto', 'never'],
                    default='auto',
                    help='''The default, auto, will check if filtering
                            causes commits to become empty (have no file
                            changes and only have one parent) and prune them
                            if so.  This pruning can also cause merge
                            commits to have fewer parents and possibly
                            become empty themselves, and thus be pruned.
                            Further, any branch or tag whose entire history
                            is pruned due to becoming empty will be pruned.
                            However, auto will not prune commits which
                            started out empty in the original repo and have
                            a non-pruned parent.''')
  misc.add_argument('--store-backup', default=None,
                    metavar='NAMESPACE', dest='backup',
                    help='Store a copy of original refs under refs/NAMESPACE/')
  misc.add_argument('--keep-excluded-refs', action='store_true',
                    help='''If refs are excluded either explicitly (e.g.
                            ^master) or implicitly (e.g. a branch in the
                            history of an excluded ref/revision, or a branch
                            not listed in the set of revisions to filter),
                            then that ref will be deleted by the filtering
                            process.  Use --keep-excluded-refs to retain
                            such refs.''')

  misc.add_argument('--keep-excluded-revisions', action='store_true',
                    help='''If negative revisions are provided to exclude
                            the range of history we are filtering over (e.g.
                            negative_branch..master or ^negative_branch_1
                            ^negative_branch_2 master develop), then by
                            default any commits in the history of those
                            revisions are excluded from the filtered history
                            (resulting in the first not-excluded commit in
                            history becoming a root commit and often
                            containing an unusually large number of file
                            changes).  With --keep-excluded-revisions, those
                            commits are all retained (in their unfiltered
                            form).''')

BFG issues:
  3 basic types:
    - nasty surprises ("bugs")
    - limited capability (only solves one usecase)
    - design problems

  Nasty surprises:
  - only works if repo is packed (can't find sizes of loose objects)
  - can fail badly if not pre-gc'ed (issue 7)
  - rewrite of files annoyingly leaves ids around if nuked by size
  - private (issue 139, issue 112) is huge principle of least surprise violation
    (randomly turned on for some types of rewrites but not others)
  - filter-content-including doesn't affect -b option
  - After replace text operation, index & working tree not updated
    - may be the 'real' reason behind blob protection?
  - Doesn't auto-repack (users think repo got bigger, may slow down)
  - Issue 221: JGit looks at pack-refs and not individual refs, causing problems
  - Issue 221: symrefs cause problems
  - Issue 116: --convert-to-git-lfs doesn't really work
    - and in Issue 215 they suggest https://github.com/bozaro/git-lfs-migrate

  Limited View:
    BFG unabashedly focuses on one usecase, which is fine, but that means...
    - Defaults that kinda work with single usecase but mesh poorly with others
    - Lacks facilities to help users know what to filter (--analyze)
    - Lack of integration with default git capabilities:
      - mailmap
      - grafts and replace refs
    - Lacking lots of filtering abilities:
      - selection by path (instead of de-selection)
      - path renaming
      - tag renaming or general ref renaming
      - pulling out one or a few subdirectories, or moving to a subdir
      - modifying user names/emails
      - modifying commit messages
      - renaming refs
    - Obviously, a complete lack of generic extension capability
      - no callback mechanism (e.g. shell, python, or whatever)
      - no facility for usage of internals as as library

  Design problems:
  - only works on pack information
    - related surprise: index & working tree not update afterward
    - related surprise: can't find sizes of loose objects
    - related surprise: can fail badly if not pre-gc'ed
  - looks at trees, not full commit info
    - file basenames only; can't selectively remove files/directories
    - related surprise: convert-to-git-lfs horribly buggy
  - only writes new history in .git/objects
    - what about auto-gc?
    - what about index/working tree update afterward?
    - what about replace refs (using or writing?)
    - if pruning empty commits, what about deleting now-unused refs?
  - writes loose objects instead of new packfile
    - could severely degrade performance for big enough cases
    - could severely degrade performance for user after rewrite
    - why tell user how to fix up afterwards instead of just doing so?
    - might be fundamental: vaunted parallelism limited if writing to same
      packfile
