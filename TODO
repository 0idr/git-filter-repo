Before widely announcing:
  - Notes on splitting
    - need to handle 1 export -> 2 imports
  - Test setup
    - Add several more tests, particularly around:
      - commit pruning
        - pruning commits that become empty
	- pruning commits that started empty and have no parent
	- not pruning commits that have changes or remain a merge commit
        - pruning parent(s) of a merge
        - coalescing common commits of a merge
	- coalescing parents of a merge when one is an ancestor of the other
	- crazy no-ff stuff
	- what about when splicing repos; does it still work?
      - ref pruning
        - tags pointing at commits which are pruned along with their history
	- refs pointing at commits which are pruned along with their history
	- refs or tags behind a negative revision specification
      - commit message rewriting
        - does it also work with repo splicing?
      - renaming, particular when it causes collisions
      - use coverage.py to direct test writing

Crazy ideas, showing filter-repo flexibility:
  - implement bfg
  - implement filter-branch (except only provide changed files)

Generate upstream patches:
  - Tags of tags of commits fail to export (so does tags of blobs):
    - In git.git, try:
      $ git fast-export --no-data --use-done-feature --signed-tags=strip \
                  --tag-of-filtered-object=rewrite-feature v1.0rc1 >/dev/null
      fatal: tag 5f4cd4ca015dc795b9f7f4fed11b3f80a60ac175 tags unexported tag!

Bigger ideas
  - Performance:
    - Smarter record_remapping -- do it lazily
    - memoize net result: dequote -> do mods -> requote
    - Smarter become-empty checks; only do more expensive checks if:
      - First parent is no longer original first parent or ancestor thereof
        - e.g. first-parent history empty, second parent becomes first parent
        - e.g. --parent-filter causes some kind of graft operation (although
               maybe we don't want to prune in this case anyway...)
      - Blob filtering is active AND the only file_changes involved correspond
        to filenames that have previously been modified.
  - Work with submodules
  - Important features
    - paths-from-file (--paths-from-file <(git ls-tree -r HEAD)
    - include-old-names-of-specified-files
      - so users don't have to look for rename data from --analyze
  - Do git rev-list --count to get idea of amount of work; show progress

Left over bits:
  - Fix up --analyze
    * shouldn't allow running --analyze with negative refspecs
    * add a --no-detect-renames option (for performance)
  - metadata
    - On second and subsequent runs, update metadata instead of overwriting
       - for maps, give beginning_hash -> end_hash, not intermediate hashes
    - OR error out if .git/filter-repo already created?
  - error out if any progress messages in stream (can't deal with them unless
    we can pass --cat-blob-fd to fast-import, and that seems non-portable)

Add a filename_callback parameter for those that want to affect just that
Add
  --blob-callback <string serving as python code>
  --commit-callback <string serving as python code>
  --tag-callback <string serving as python code>
and two special ones:
  --refname-callback <string serving as python code>
  --filename-callback <string serving as python code>


Safety stuff
  --keep-excluded-revisions
  --keep-excluded-refs
  --store-backup
  --empty-pruning={no/off,auto,always/on}
  --no-ff-pruning={no/off,auto,always/on}
  --negative-refs={drop,reference}

Other things:
  - add --skip-cleanup (pruning, gc, etc.; keep reset --hard) for speed compare

Argument parsing stuff:
  # NOT YET IMPLEMENTED OPTIONS BELOW
  misc.add_argument('--empty-pruning', choices=['always', 'auto', 'never'],
                    default='auto',
                    help='''The default, auto, will check if filtering
                            causes commits to become empty (have no file
                            changes and only have one parent) and prune them
                            if so.  This pruning can also cause merge
                            commits to have fewer parents and possibly
                            become empty themselves, and thus be pruned.
                            Further, any branch or tag whose entire history
                            is pruned due to becoming empty will be pruned.
                            However, auto will not prune commits which
                            started out empty in the original repo and have
                            a non-pruned parent.''')
  misc.add_argument('--store-backup', default=None,
                    metavar='NAMESPACE', dest='backup',
                    help='Store a copy of original refs under refs/NAMESPACE/')
  misc.add_argument('--keep-excluded-refs', action='store_true',
                    help='''If refs are excluded either explicitly (e.g.
                            ^master) or implicitly (e.g. a branch in the
                            history of an excluded ref/revision, or a branch
                            not listed in the set of revisions to filter),
                            then that ref will be deleted by the filtering
                            process.  Use --keep-excluded-refs to retain
                            such refs.''')

  misc.add_argument('--keep-excluded-revisions', action='store_true',
                    help='''If negative revisions are provided to exclude
                            the range of history we are filtering over (e.g.
                            negative_branch..master or ^negative_branch_1
                            ^negative_branch_2 master develop), then by
                            default any commits in the history of those
                            revisions are excluded from the filtered history
                            (resulting in the first not-excluded commit in
                            history becoming a root commit and often
                            containing an unusually large number of file
                            changes).  With --keep-excluded-revisions, those
                            commits are all retained (in their unfiltered
                            form).''')
